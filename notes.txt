Stateless functional component: JS functions, simply return html (read jsx), optionally take in props as param.
Stateful class component: ES6 class extending Component class, must contain render method that returns html.

Fb has over 30k components!

Stateless functional component: Properties (props) -> JS Function -> HTML (JSX)
- If there is no content between tags, then you can self-close the tag.
- Class component can also receive props, has an internal state and returns an HTML (JSX)
- For a class component, React along with Component must be imported.

Functional Component:
- Simple functions
- Use function components as much as possible
- Absence of 'this' keyword
- Forced to think of a solution without using state
- Mainly responsible for the UI
- Stateless/Dumb/Presentational components

Class Component:
- More feature rich
- Maintain their own private data - state
- Complex UI logic
- Provide lifecycle hooks
- Stateful/Smart/Container components

In react conf 2018, in react 16.7.0-alpha, they've announced hooks.
Hooks let you use state and other class features without writing a class.
No breaking changes!

JSX:
- Extension to JS language syntax.
- Write XML-like code for elements and components
- JSX tags have a tag name, attributes and children
- JSX is not a necessity to write React apps
- JSX makes your code concise, simpler and elegant
- JSX ultimately transpiles to pure JS which is understood by browsers.

- Each JSX call translates into a call to React.createElement.

JSX differences:
class -> className
for -> htmlFor
camelCase prop naming convention: onclick -> onClick, tabindex -> tabIndex

- className will change to class in React 18 probably.
- props is immutable

props vs. state:
props: 
- props get passed to component
- received as function parameters
- props are immutable
- props - Functional Components
this.props - Class Components

state:
- state is managed within the component
- variables declared in the function body
- state can be changed
- useState Hook - Functional Components
this.state - Class Components

- If you change this.state.count, then it wont re-render the DOM. You have to use this.setState();
- Calls to this.setState() are async. Meaning that if you try to reuse that value elsewhere, it wont be the same. Async:
this.setState({
	count: this.state.count + 1
});
console.log(this.state.count); // Inconsistent output

Sync (print message after state is updated through callback):
this.setState({
	count: this.state.count + 1
}, () => {
	console.log(this.state.count); // expected output
});

- multiple calls to setState where we have to update the state based on the previous state, simply pass a function to setState with the prevState as parameter. Otherwise, the calls will be grouped into one update call and inaccurate results will show.

- props are destructured differently in class component and functional component.

- Inside a functional component, if we do: 
function clickHandler() {
	console.log('Button clicked');
}

<button onClick={clickHandler}>Click!</button> 

Notice that we are passing the clickHandler handler instead of calling the function like clickHandler() because if we do that, then it will call the function without us having clicked it and will never call it when we click on button.

- this keyword is null in a class, unless you bind it.
1st approach: 
this.clickHandler.bind(this) 
is one way of binding it. Problem with this is that every setState will re-render the component, and render method will be called and so there will be a new event handler every time.

2nd approach: 
<button onClick={() => this.clickHandler()}>Btn</button>
is another way. Here we are calling the function. But same problem as above.

3rd approach (used by Fb as well):
Use 1st approach but in constructor.
class A extends Component {
	constructor() {
		...
		...
		this.clickHandler = this.clickHandler.bind(this)
	}
}

4th approach:
Define the method as an arrow function like so:
class X extends Component {
	constructor() {
		...
	}

	clickHandler = () => {

	}
}

Conditional rendering:
1) if else
2) Ternary operator
4) Short circuit operator: 
render() {
	this.state.isLoggedIn && <div>Welcome</div>
}

lists:


- You cant access key passed from prop inside the child element.

The below two lists only differ in the last element. React iterates over both lists and computes the difference, and sees that only the last element is different. React then mutates the DOM accordingly.
<ul>
	<li>Bruce</li>
	<li>Clarke</li>
</ul>

<ul>
	<li>Bruce</li>
	<li>Clarke</li>
	<li>Diana</li>
</ul>

Now, if we have:
<ul>
	<li>Bruce</li>
	<li>Clarke</li>
</ul>

<ul>
	<li>Diana</li>
	<li>Bruce</li>
	<li>Clarke</li>
</ul>

React will now compare the two lists, and finds that the two lists differ, so it renders the updated list completely without realising that two elements are indeed the same.
Hence we use keys as props in lists.

Index as key anti-pattern:
<ul>
	<li key="0">1</li>
	<li key="1">2</li>
	<li key="2">3</li>
</ul>

If you insert a new element at the top, it will have key="0" but React will think its value is 1 like before instead of blank.
Only use index as key if:
1. there is no unique id in a list
2. list is a static list and will not change
3. list will never be reordered or filtered

Styling React components:
1. CSS stylesheets
2. Inline Styling
3. CSS Modules
4. CSS in JS libraries (name of library: styled components)

- module approach of styling doesnt cause conflicts, whereas stylesheets apply to parent as well as child components.

Controlled components:
- such elements whose value is controlled by react is a controlle component.

Lifecycle methods:
- they dont exist on a functional component
- we can override them on class components

Mounting: When an instance of a component is being created and inserted into DOM
Updating: When a component is being re-rendered as a result of changes to either its props or state
Unmounting: When a component is being removed from DOM
Error handling: When there is an error during rendering, in a lifecycle method or in the constructor of any child component.

Mounting: constructor, static getDerivedStateFromProps, render and componentDidMount
Updating: static getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, and componentDidUpdate
Unmounting: componentWillUnmount
Error Handling: static getDerivedStateFromError, and componentDidCatch

Mounting lifecycle methods:
In the order they're invoked:
1. constructor(props) - a special function that gets called whenever a new component is created.
It's used for initializing state and binding event handlers. Do not cause side-effects. Ex. HTTP requests.
Must call super(props) which calls constructor of Component to have access to props. 
Only place where you can directly overwrite state. this.state(...)
2. static getDerivedStateFromProps(props, state) - when the state of component depends on changes in props over time.
If the initial state of the component depends on props, then you use this method to set the state. it's a static method.
doesnt have access to this keyword. You return the new object representing the new state.
