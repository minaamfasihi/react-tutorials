Stateless functional component: JS functions, simply return html (read jsx), optionally take in props as param.
Stateful class component: ES6 class extending Component class, must contain render method that returns html.

Fb has over 30k components!

Stateless functional component: Properties (props) -> JS Function -> HTML (JSX)
- If there is no content between tags, then you can self-close the tag.
- Class component can also receive props, has an internal state and returns an HTML (JSX)
- For a class component, React along with Component must be imported.

Functional Component:
- Simple functions
- Use function components as much as possible
- Absence of 'this' keyword
- Forced to think of a solution without using state
- Mainly responsible for the UI
- Stateless/Dumb/Presentational components

Class Component:
- More feature rich
- Maintain their own private data - state
- Complex UI logic
- Provide lifecycle hooks
- Stateful/Smart/Container components

In react conf 2018, in react 16.7.0-alpha, they've announced hooks.
Hooks let you use state and other class features without writing a class.
No breaking changes!

JSX:
- Extension to JS language syntax.
- Write XML-like code for elements and components
- JSX tags have a tag name, attributes and children
- JSX is not a necessity to write React apps
- JSX makes your code concise, simpler and elegant
- JSX ultimately transpiles to pure JS which is understood by browsers.

- Each JSX call translates into a call to React.createElement.

JSX differences:
class -> className
for -> htmlFor
camelCase prop naming convention: onclick -> onClick, tabindex -> tabIndex

- className will change to class in React 18 probably.
- props is immutable

props vs. state:
props: 
- props get passed to component
- received as function parameters
- props are immutable
- props - Functional Components
this.props - Class Components

state:
- state is managed within the component
- variables declared in the function body
- state can be changed
- useState Hook - Functional Components
this.state - Class Components

- If you change this.state.count, then it wont re-render the DOM. You have to use this.setState();
- Calls to this.setState() are async. Meaning that if you try to reuse that value elsewhere, it wont be the same. Async:
this.setState({
	count: this.state.count + 1
});
console.log(this.state.count); // Inconsistent output

Sync (print message after state is updated through callback):
this.setState({
	count: this.state.count + 1
}, () => {
	console.log(this.state.count); // expected output
});

- multiple calls to setState where we have to update the state based on the previous state, simply pass a function to setState with the prevState as parameter. Otherwise, the calls will be grouped into one update call and inaccurate results will show.

- props are destructured differently in class component and functional component.

- Inside a functional component, if we do: 
function clickHandler() {
	console.log('Button clicked');
}

<button onClick={clickHandler}>Click!</button> 

Notice that we are passing the clickHandler handler instead of calling the function like clickHandler() because if we do that, then it will call the function without us having clicked it and will never call it when we click on button.

- this keyword is null in a class, unless you bind it.
1st approach: 
this.clickHandler.bind(this) 
is one way of binding it. Problem with this is that every setState will re-render the component, and render method will be called and so there will be a new event handler every time.

2nd approach: 
<button onClick={() => this.clickHandler()}>Btn</button>
is another way. Here we are calling the function. But same problem as above.

3rd approach (used by Fb as well):
Use 1st approach but in constructor.
class A extends Component {
	constructor() {
		...
		...
		this.clickHandler = this.clickHandler.bind(this)
	}
}

4th approach:
Define the method as an arrow function like so:
class X extends Component {
	constructor() {
		...
	}

	clickHandler = () => {

	}
}

